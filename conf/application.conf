play.application.loader = "querki.system.QuerkiApplicationLoader"

# Common values for cluster setup
clustering {
  ip = "127.0.0.1"
  ip = ${?CLUSTER_IP}
  port = 1600
  port = ${?CLUSTER_PORT}
  seed-ip = "127.0.0.1"
  seed-ip = ${?CLUSTER_IP}
  seed-ip = ${?SEED_PORT_1600_TCP_ADDR}
  seed-port = 1600
  seed-port = ${?SEED_PORT_1600_TCP_PORT}
  cluster.name = poc-cluster
}

# Configuration for Play's internal ActorSystem
play.akka.config = "play-akka"
play-akka {
  akka {
    remote {
      log-remote-lifecycle-events = off
      artery.canonical {
        hostname = "127.0.0.1"
        port = 2552
      }
    }

    cluster {
      # This is the fallback setup, for when we're not actually running under ConductR:
      seed-nodes = [
        "akka://application@127.0.0.1:2552"
      ]
    }
  }
}

# Configuration for the application's ActorSystems
akka {
  loglevel = debug

  actor {
    provider = "cluster"
    debug {
      receive = off
      lifecycle = off
    }
  }

  remote {
    log-remote-lifecycle-events = on
    artery {
      enabled = on

      canonical {
        hostname = ${clustering.ip}
        port = ${clustering.port}
      }
#
#      bind {
#        hostname = "127.0.0.1"
#        port = ${clustering.port}
#      }
    }
  }

  cluster {
    # In real Querki, we will want to have all nodes set up as seeds, probably, with dynamic discovery:
    seed-nodes = [
      "akka://"${clustering.cluster.name}"@"${clustering.seed-ip}":"${clustering.seed-port}
    ]
#    downing-provider-class = "akka.cluster.sbr.SplitBrainResolverProvider"
    # IMPORTANT: this is solely for the proof of concept app -- Querki must not go anywhere near auto-downing!
    akka.cluster.auto-down-unreachable-after = 120s
  }
}
